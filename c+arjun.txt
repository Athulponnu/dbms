1st
#include <stdio.h> 
#include <stdlib.h> 
struct TreeNode { 
int val; 
struct TreeNode* left; 
struct TreeNode* right; 
}; 
struct TreeNode* newNode(int val) { 
struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode)); 
node->val = val; 
node->left = node->right = NULL; 
return node; 
} 
void inorder(struct TreeNode* root) { 
if (root != NULL) { 
inorder(root->left); 
printf("%d ", root->val); 
inorder(root->right); 
} 
} 
void preorder(struct TreeNode* root) { 
if (root != NULL) { 
printf("%d ", root->val);            
preorder(root->left); 
preorder(root->right); 
} 
} 
void postorder(struct TreeNode* root) { 
if (root != NULL) { 
postorder(root->left); 
postorder(root->right); 
printf("%d ", root->val); 
} 
} 
int main() { 
struct TreeNode* root = newNode(1); 
root->left = newNode(2); 
root->right = newNode(3); 
root->left->left = newNode(4); 
root->left->right = newNode(5); 
printf("Inorder: "); 
inorder(root); 
printf("\nPreorder: "); 
preorder(root); 
printf("\nPostorder: "); 
postorder(root); 
return 0; 
}
OUTPUT: 
Inorder: 4 2 5 1 3 
Preorder: 1 2 4 5 3 
Postorder: 4 5 2 3 1 





2nd
PROGRAM: 
#include <stdio.h> 
#include <stdlib.h> 
struct TreeNode { 
int val; 
struct TreeNode* left; 
struct TreeNode* right; 
}; 
int maxDiameter = 0; 
struct TreeNode* newNode(int val) { 
struct TreeNode* node = (struct TreeNode*)malloc(sizeof(struct TreeNode)); 
node->val = val; 
node->left = node->right = NULL; 
return node; 
} 
int height(struct TreeNode* node) { 
if (node == NULL) return 0; 
int left = height(node->left); 
int right = height(node->right); 
if (left + right > maxDiameter) maxDiameter = left + right; 
return 1 + (left > right ? left : right); 
} 
int diameter(struct TreeNode* root) { 
maxDiameter = 0; 
height(root); 
return maxDiameter; 
} 
int main() { 
struct TreeNode* root = newNode(1); 
root->left = newNode(2); 
root->right = newNode(3); 
root->left->left = newNode(4); 
root->left->right = newNode(5); 
printf("Diameter of the binary tree is: %d\n", diameter(root)); 
return 0; 
} 
OUTPUT: 
Diameter of the binary tree is: 3


3rd
PROGRAM: 
#include <stdio.h> 
#include <stdlib.h> 
#include <stdbool.h> 
#define V 5 
struct Node { 
int vertex; 
struct Node* next; 
}; 
struct Graph { 
struct Node* adjLists[V]; 
}; 
struct Node* createNode(int v) { 
struct Node* newNode = malloc(sizeof(struct Node)); 
newNode->vertex = v; 
newNode->next = NULL; 
return newNode; 
} 
void addEdge(struct Graph* graph, int src, int dest) { 
struct Node* newNode = createNode(dest); 
newNode->next = graph->adjLists[src]; 
graph->adjLists[src] = newNode; 
newNode = createNode(src); 
newNode->next = graph->adjLists[dest]; 
graph->adjLists[dest] = newNode; 
} 
void bfs(struct Graph* graph, int startVertex) { 
bool visited[V] = {false}; 
int distance[V]; 
for (int i = 0; i < V; i++) distance[i] = -1; 
int queue[V], front = 0, rear = 0; 
visited[startVertex] = true; 
distance[startVertex] = 0; 
queue[rear++] = startVertex; 
while (front < rear) { 
int currentVertex = queue[front++]; 
struct Node* temp = graph->adjLists[currentVertex]; 
while (temp) { 
int adjVertex = temp->vertex; 
if (!visited[adjVertex]) { 
visited[adjVertex] = true; 
distance[adjVertex] = distance[currentVertex] + 1; 
queue[rear++] = adjVertex; 
} 
temp = temp->next; 
} 
} 
for (int i = 0; i < V; i++) { 
printf("Distance from %d to %d is %d\n", startVertex, i, distance[i]); 
} 
} 
int main() { 
struct Graph* graph = malloc(sizeof(struct Graph)); 
for (int i = 0; i < V; i++) graph->adjLists[i] = NULL; 
addEdge(graph, 0, 1); 
addEdge(graph, 0, 3); 
addEdge(graph, 1, 2); 
addEdge(graph, 2, 4); 
addEdge(graph, 3, 4); 
bfs(graph, 0); 
return 0; 
} 
OUTPUT: 
Distance from 0 to 0 is 0 
Distance from 0 to 1 is 1 
Distance from 0 to 2 is 2 
Distance from 0 to 3 is 1 
Distance from 0 to 4 is 2


4th
PROGRAM: 
#include <stdio.h> 
#include <stdlib.h> 
#include <stdbool.h> 
#define MAX_VERTICES 100 
// Node structure for adjacency list 
struct Node { 
int vertex; 
struct Node* next; 
}; 
// Graph structure 
struct Graph { 
int vertices; 
struct Node* adjLists[MAX_VERTICES]; 
bool visited[MAX_VERTICES]; 
}; 
// Function to create a node 
struct Node* createNode(int v) { 
struct Node* newNode = malloc(sizeof(struct Node)); 
newNode->vertex = v; 
newNode->next = NULL; 
return newNode; 
} 
// Initialize the graph 
struct Graph* createGraph(int vertices) { 
struct Graph* graph = malloc(sizeof(struct Graph)); 
graph->vertices = vertices; 
for (int i = 0; i < vertices; i++) { 
graph->adjLists[i] = NULL; 
graph->visited[i] = false; 
} 
return graph; 
} 
// Add edge (undirected) 
void addEdge(struct Graph* graph, int src, int dest) { 
    struct Node* newNode = createNode(dest); 
    newNode->next = graph->adjLists[src]; 
    graph->adjLists[src] = newNode; 
    newNode = createNode(src); 
    newNode->next = graph->adjLists[dest]; 
    graph->adjLists[dest] = newNode; 
} 
 
// DFS function 
void DFS(struct Graph* graph, int vertex) { 
    graph->visited[vertex] = true; 
    printf("%d ", vertex); 
 
    struct Node* temp = graph->adjLists[vertex]; 
    while (temp) { 
        int adjVertex = temp->vertex; 
        if (!graph->visited[adjVertex]) { 
            DFS(graph, adjVertex); 
        } 
        temp = temp->next; 
    } 
} 
 
// Identify connected components 
void findConnectedComponents(struct Graph* graph) { 
    int count = 0; 
    for (int i = 0; i < graph->vertices; i++) { 
        if (!graph->visited[i]) { 
            printf("Component %d: ", ++count); 
            DFS(graph, i); 
            printf("\n"); 
        } 
    } 
} 
 
int main() { 
    int vertices = 7; 
    struct Graph* graph = createGraph(vertices); 
    // Add edges 
    addEdge(graph, 0, 1); 
    addEdge(graph, 0, 2); 
    addEdge(graph, 3, 4); 
    addEdge(graph, 5, 6); 
    printf("Connected components in the graph:\n"); 
    findConnectedComponents(graph); 
 
    return 0; 
} 
 
 
OUTPUT: 
Connected components in the graph: 
Component 1: 0 1 2  
Component 2: 3 4  
Component 3: 5 6 

5thPROGRAM: 
 
#include <stdio.h> 
#include <stdlib.h> 
 
#define MAX 20  // Maximum board size 
 
int board[MAX]; 
int N; 
 
void printSolution() { 
    for (int i = 0; i < N; i++) { 
        for (int j = 0; j < N; j++) { 
            if (board[i] == j) 
                printf(" Q "); 
            else 
                printf(" . "); 
        } 
        printf("\n"); 
    } 
    printf("\n"); 
} 
 
int isSafe(int row, int col) { 
    for (int i = 0; i < row; i++) { 
        if (board[i] == col || abs(board[i] - col) == abs(i - row)) 
            return 0; 
    } 
    return 1; 
} 
 
void solveNQueens(int row) { 
    if (row == N) { 
        printSolution(); 
        return; 
    } 
 
    for (int col = 0; col < N; col++) { 
        if (isSafe(row, col)) { 
            board[row] = col; 
            solveNQueens(row + 1); 
            // No need to reset board[row] because it will be overwritten 
        } 
    } 
} 
 
int main() { 
    printf("Enter the value of N (1 to %d): ", MAX); 
    scanf("%d", &N); 
 
    if (N < 1 || N > MAX) { 
        printf("Invalid board size.\n"); 
        return 1; 
    } 
 
    printf("Solutions for %d-Queens problem:\n\n", N); 
    solveNQueens(0); 
 
    return 0; 
} 
 
OUTPUT: 
Enter the value of N (1 to 20): 4 
Solutions for 4-Queens problem: 
.  Q  .  . 
.  .  .  Q 
Q  .  .  . 
.  .  Q  . 
.  .  Q  . 
Q  .  .  . 
.  .  .  Q 
.  Q  .  .


6th
PROGRAM: 
#include <stdio.h> 
#define UNASSIGNED 0 
#define N 9 
// Function to print the grid 
void printGrid(int grid[N][N]) { 
for (int row = 0; row < N; row++) { 
for (int col = 0; col < N; col++) { 
printf("%2d", grid[row][col]); 
} 
printf("\n"); 
} 
} 
// Check if it's safe to place num at grid[row][col] 
int isSafe(int grid[N][N], int row, int col, int num) { 
// Check row and column 
for (int x = 0; x < N; x++) { 
if (grid[row][x] == num || grid[x][col] == num) 
return 0; 
} 
// Check 3x3 subgrid 
int startRow = row - row % 3; 
int startCol = col - col % 3; 
for (int i = 0; i < 3; i++) 
for (int j = 0; j < 3; j++) 
if (grid[i + startRow][j + startCol] == num) 
return 0; 
return 1; 
} 
// Find unassigned location in the grid 
int findUnassigned(int grid[N][N], int *row, int *col) { 
for (*row = 0; *row < N; (*row)++) 
for (*col = 0; *col < N; (*col)++) 
if (grid[*row][*col] == UNASSIGNED) 
return 1; 
return 0; 
} 
// Main solver function using backtracking 
int solveSudoku(int grid[N][N]) { 
int row, col; 
if (!findUnassigned(grid, &row, &col)) 
return 1;  // Puzzle solved 
 
    for (int num = 1; num <= 9; num++) { 
        if (isSafe(grid, row, col, num)) { 
            grid[row][col] = num; 
 
            if (solveSudoku(grid)) 
                return 1; 
 
            grid[row][col] = UNASSIGNED; // Backtrack 
        } 
    } 
 
    return 0; // Trigger backtracking 
} 
 
// Main function 
int main() { 
    int grid[N][N] = { 
        {5, 3, 0, 0, 7, 0, 0, 0, 0}, 
        {6, 0, 0, 1, 9, 5, 0, 0, 0}, 
        {0, 9, 8, 0, 0, 0, 0, 6, 0}, 
        {8, 0, 0, 0, 6, 0, 0, 0, 3}, 
        {4, 0, 0, 8, 0, 3, 0, 0, 1}, 
        {7, 0, 0, 0, 2, 0, 0, 0, 6}, 
        {0, 6, 0, 0, 0, 0, 2, 8, 0}, 
        {0, 0, 0, 4, 1, 9, 0, 0, 5}, 
        {0, 0, 0, 0, 8, 0, 0, 7, 9} 
    }; 
 
    if (solveSudoku(grid) == 1) 
        printGrid(grid); 
    else 
        printf("No solution exists.\n"); 
 
    return 0; 
} 
 

OUTPUT: 
 
5 3 4 6 7 8 9 1 2 
6 7 2 1 9 5 3 4 8 
1 9 8 3 4 2 5 6 7 
8 5 9 7 6 1 4 2 3 
4 2 6 8 5 3 7 9 1 
7 1 3 9 2 4 8 5 6 
9 6 1 5 3 7 2 8 4 
2 8 7 4 1 9 6 3 5 
3 4 5 2 8 6 1 7 9


7th
PROGRAM : 
#include <stdio.h> 
int compute(int n) { 
if (n <= 1) return n; 
int dp[n + 1]; 
dp[0] = 0; 
dp[1] = 1; 
for (int i = 2; i <= n; i++) { 
dp[i] = dp[i - 1] + dp[i - 2]; 
} 
return dp[n]; 
} 
int main() { 
int n; 
printf("Enter the value of n: "); 
scanf("%d", &n); 
if (n < 0) { 
printf("Please enter a non-negative integer.\n"); 
return 1; 
} 
int result = compute(n); 
printf("Fibonacci number at position %d is: %d\n", n, result); 
return 0; 
} 
OUTPUT: 
Enter the value of n: 10 
Fibonacci number at position 10 is: 55

8th
PROGRAM : 
#include <stdio.h> 
#include <string.h> 
// Function to find the length of the LCS 
int LCS(char *X, char *Y) { 
int m = strlen(X); 
int n = strlen(Y); 
int dp[m+1][n+1]; 
// Build the LCS table in bottom-up fashion 
for (int i = 0; i <= m; i++) { 
for (int j = 0; j <= n; j++) { 
if (i == 0 || j == 0) 
dp[i][j] = 0;  // Base case 
            else if (X[i-1] == Y[j-1]) 
                dp[i][j] = dp[i-1][j-1] + 1;  // Match found 
            else 
                dp[i][j] = (dp[i-1][j] > dp[i][j-1]) ? dp[i-1][j] : dp[i][j-1];  // Take max 
        } 
    } 
 
    return dp[m][n]; // The bottom-right cell contains the length of LCS 
} 
 
int main() { 
    char str1[100], str2[100]; 
 
    printf("Enter first string: "); 
    scanf("%s", str1); 
 
    printf("Enter second string: "); 
    scanf("%s", str2); 
 
    int lcs_length = LCS(str1, str2); 
    printf("Length of Longest Common Subsequence: %d\n", lcs_length); 
 
    return 0; 
} 
 

OUTPUT: 
Enter first string: AGGTAB 
Enter second string: GXTXAYB 
Length of Longest Common Subsequence: 4



9th
PROGRAM: 
#include <stdio.h> 
#include <stdlib.h> 
void merge(int arr[], int left[], int leftSize, int right[], int rightSize) { 
int i = 0, j = 0, k = 0; 
while (i < leftSize && j < rightSize) { 
arr[k++] = (left[i] <= right[j]) ? left[i++] : right[j++]; 
} 
while (i < leftSize) arr[k++] = left[i++]; 
while (j < rightSize) arr[k++] = right[j++]; 
} 
void sort(int arr[], int size) { 
if (size > 1) { 
int mid = size / 2; 
int* left = (int*)malloc(mid * sizeof(int)); 
int* right = (int*)malloc((size - mid) * sizeof(int)); 
for (int i = 0; i < mid; i++) left[i] = arr[i]; 
for (int i = mid; i < size; i++) right[i - mid] = arr[i]; 
sort(left, mid); 
sort(right, size - mid); 
merge(arr, left, mid, right, size - mid); 
 
        free(left); 
        free(right); 
    } 
} 
 
int main() { 
    int n; 
    printf("Enter number of elements: "); 
    scanf("%d", &n); 
 
    if (n <= 0) { 
        printf("Invalid array size.\n"); 
        return 1; 
    } 
 
    int* arr = (int*)malloc(n * sizeof(int)); 
 
    printf("Enter %d elements:\n", n); 
    for (int i = 0; i < n; i++) { 
        scanf("%d", &arr[i]); 
    } 
 
    sort(arr, n); 
 
    printf("Sorted array: "); 
    for (int i = 0; i < n; i++) { 
        printf("%d ", arr[i]); 
    } 
    printf("\n"); 
 
    free(arr); 
    return 0; 
} 
#include <stdio.h> 
#include <stdlib.h> 
 
void merge(int arr[], int left[], int leftSize, int right[], int rightSize) { 
    int i = 0, j = 0, k = 0; 
    while (i < leftSize && j < rightSize) { 
        arr[k++] = (left[i] <= right[j]) ? left[i++] : right[j++]; 
    } 
    while (i < leftSize) arr[k++] = left[i++]; 
    while (j < rightSize) arr[k++] = right[j++]; 
} 
 
void sort(int arr[], int size) { 
    if (size > 1) { 
        int mid = size / 2; 
        int* left = (int*)malloc(mid * sizeof(int)); 
        int* right = (int*)malloc((size - mid) * sizeof(int)); 
 
        for (int i = 0; i < mid; i++) left[i] = arr[i]; 
        for (int i = mid; i < size; i++) right[i - mid] = arr[i]; 
 
        sort(left, mid); 
        sort(right, size - mid); 
 
        merge(arr, left, mid, right, size - mid); 
 
        free(left); 
        free(right); 
    } 
} 
 
int main() { 
    int n; 
    printf("Enter number of elements: "); 
    scanf("%d", &n); 
 
    if (n <= 0) { 
        printf("Invalid array size.\n"); 
        return 1; 
    } 
 
    int* arr = (int*)malloc(n * sizeof(int)); 
 
    printf("Enter %d elements:\n", n); 
    for (int i = 0; i < n; i++) { 
        scanf("%d", &arr[i]); 
    } 
 
    sort(arr, n); 
 
    printf("Sorted array: "); 
    for (int i = 0; i < n; i++) { 
        printf("%d ", arr[i]); 
    } 
    printf("\n"); 
 
    free(arr); 
    return 0; 
} 
 

 
OUTPUT: 
Enter number of elements: 5 
Enter 5 elements: 
12 11 13 5 6 
Sorted array: 5 6 11 12 13